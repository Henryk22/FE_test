<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms_HW1_HBorisow</title>
</head>
<body>
    <script>
//   7-14.03

//   Palindrome Number
//       Given an integer x, return true if x is a palindrome, and false otherwise.

//   Find the element that appears once in a sorted array
//  Given a sorted array in which all elements occur twice (one after the other) and one element appears only once.
//   ==
//   Число палиндрома
//  Дано целое число x, вернуть true, если x является палиндромом, и false в противном случае.

//  

//   ==
//  Решение
//   Нужно проверить, является ли данное число симметричным. 
//   Для этого можно сравнить первую и последнюю цифры числа, затем вторую и предпоследнюю и т.д., 
//   пока не останется одна цифра или не будет обнаружено несоответствие.

//   Алгоритм:

//  1 Преобразовать число в строку.
//  2 Используем два указателя: один указывает на первый символ, а второй указывает на последний символ.
//  3 Сравнить символы на обоих концах и перемещаться ближе к центру, продолжать сравнивать, пока они не встретятся.
//  4 Если все символы были проверены и не было найдено несоответствие, то число является палиндромом, вернуть true. Иначе, вернуть false.

// function Palindrome(x) { //объявляем функцию Palindrome, которая принимает один аргумент x - целое число
//   const str = x.toString(); //преобразуем число в строку, используя метод toString(), и сохраняем результат в переменной str.
//   let left = 0; //создаем  переменные left и right, которые будут использоваться для прохода по строке str в поиске палиндромов.
//   let right = str.length - 1;
  
//   while (left < right) { // используем цикл while, который будет выполняться до тех пор, пока значения left и right не сравняются. 
    
    
//     if (str[left] !== str[right]) {// В каждой итерации цикла мы сравниваем символы, находящиеся на позициях left и right в строке str.
//       return false; // Если символы не совпадают, то функция возвращает false, так как число не является палиндромом.
//     }
//     left++; //  eсли символы совпадают, мы увеличиваем значение left 
//     right--; //и уменьшаем значение right, чтобы продолжить поиск по строке.
//   }
//   return true; //Если цикл завершается и все символы в строке str совпадают, то функция возвращает true, так как число является палиндромом.
// }
// console.log(Palindrome(1333331)); // проверяем
// =======================================

//   Дан отсортированный массив, в котором все элементы встречаются дважды (один за другим), а один элемент встречается только один раз.
//  Найдите элемент, который появляется один раз в отсортированном массиве.

// Алгоритм:

// 1 Инициализируем левую и правую границы (left и right) массива.
// 2 Находим средний индекс (mid) массива, который будет равен (left + right) / 2.
// 3 Если значение элемента с индексом mid равно значению элемента с индексом mid - 1, то искомый элемент находится в левой части массива, и мы продолжаем поиск на этой половине массива, устанавливая правую границу на mid - 2.
// 3.1 Если значение элемента с индексом mid равно значению элемента с индексом mid + 1, то искомый элемент находится в правой части массива, и мы продолжаем поиск на этой половине массива, устанавливая левую границу на mid + 2.
// 3.2 Если ни одно из условий не выполнено, то элемент с индексом mid является искомым элементом.


let arr = [1, 1, 2, 2, 3, 3, 4, 4, 5];

function findSingle(arr) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);

    // если значение элемента с индексом mid равно значению элемента с индексом mid - 1, искомый элемент находится в левой части массива
    if (arr[mid] === arr[mid - 1]) {
      right = mid - 2;
    }
    // если значение элемента с индексом mid равно значению элемента с индексом mid + 1, искомый элемент находится в правой части массива
    else if (arr[mid] === arr[mid + 1]) {
      left = mid + 2;
    }
    // иначе элемент с индексом mid является искомым элементом
    else {
      return arr[mid];
    }
  }
}

// Checked

console.log(findSingle(arr)); // 5

//Функция findSingle принимает отсортированный массив и возвращает элемент, который встречается только один раз в массиве.


//===============================
// Вариант с XOR == не готов
//  Algorithm
// 1 Используем операцию XOR для всех элементов массива.  XOR является простым и эффективным способом нахождения элемента, который встречается только один раз в отсортированном массиве. 
// 2 В результате мы получим значение, которое включает только элемент, который встречается один раз.
// 3 Возвращаем это значение.

// function findSingle(arr) { //объявляем функцию findSingle, которая принимает один аргумент arr - отсортированный массив, 
// //в котором все элементы встречаются дважды, за исключением одного элемента. 
//   let result = 0; //Внутри функции мы создаем переменную result и присваиваем ей начальное значение 0.

//   for (let i = 0; i < arr.length; i+2) { //Проходимся по всем элементам массива циклом for. 
//     result ^= arr[i]; //В каждой итерации мы используем операцию XOR (^=) (exclusive oder)
//     //  для текущего элемента массива и переменной result. 
//     //  Операция XOR возвращает значение 1, если только один из операндов равен 1, и 0 в противном случае.
//     //  Если элемент повторяется в массиве, то при выполнении операции XOR дважды его значение будет обнулено.
//     //  Eсли элемент встречается только один раз, то его значение сохранится в result.
//   }

//   return result;
// }
// console.log(findSingle(224455337668899))


    </script>
</body>
</html>